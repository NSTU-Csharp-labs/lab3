using System;using System.Reactive;using System.Reactive.Disposables;using System.Reactive.Linq;using System.Threading.Tasks;using System.Xml.Serialization;using lab3.Controls.GL;using lab3.ViewModels;using ReactiveUI;namespace lab3.Controls.MainWindow;[Serializable]public class MainWindowViewModel : ViewModelBase, IActivatableViewModel{    public readonly Interaction<Unit, string[]> ShowOpenDirectoryDialog;    private ImgBitmap _bitmap;    private bool _blackAndWhiteFilter;    private bool _blueFilter;    private bool _greenFilter;    private bool _isCheckedB;    private bool _isCheckedBW;    private bool _isCheckedG;    private bool _isCheckedR;    private bool _isVisibleDrawBtn = true;    private bool _isVisibleEffectBtn = true;    private bool _isVisibleEffectsElements;    private bool _isVisibleRotateBtn = true;    private bool _isVisibleSaveBtn = true;    private bool _redFilter;    private IBackUpSerializer _serializer;    public MainWindowViewModel()    {        _serializer = new BackUpSerializer("../../../BackUp.xml");        Activator = new ViewModelActivator();        Bitmap = new ImgBitmap(0, 0, new byte[] { });        PictureManager = new ImageManager();        ShowOpenDirectoryDialog = new Interaction<Unit, string[]>();        OpenImage = ReactiveCommand.CreateFromTask(OnOpenDirectory);        Rotate = ReactiveCommand.CreateFromTask(async () =>        {            PictureManager.DoRightRotation();            await _serializer.BackUp(this);        });        SwipeLeft = ReactiveCommand.CreateFromTask(async () =>        {            PictureManager.SwipeLeft();            await _serializer.BackUp(this);        });        SwipeRight = ReactiveCommand.CreateFromTask(async () =>        {            PictureManager.SwipeRight();            await _serializer.BackUp(this);        });        EnableEffects = ReactiveCommand.Create(() =>        {            BlueFilter = IsCheckedB;            GreenFilter = IsCheckedG;            RedFilter = IsCheckedR;            BlackAndWhiteFilter = IsCheckedBW;        });        OpenEffects = ReactiveCommand.Create(() =>        {            IsVisibleEffectsElements = true;            IsVisibleSaveBtn = false;            IsVisibleDrawBtn = false;            IsVisibleEffectBtn = false;            IsVisibleRotateBtn = false;        });        BackFromEffects = ReactiveCommand.Create(() =>        {            IsVisibleEffectsElements = false;            IsVisibleSaveBtn = true;            IsVisibleDrawBtn = true;            IsVisibleEffectBtn = true;            IsVisibleRotateBtn = true;        });        this.WhenActivated(d =>            {                PictureManager.BitmapChanged.Subscribe(async bitmap =>                {                    Bitmap = bitmap;                    await _serializer.BackUp(this);                }).DisposeWith(d);                PictureManager.DisposeWith(d);            }        );    }    public ImageManager PictureManager { get; set; }    [XmlIgnore]    public ImgBitmap Bitmap    {        get => _bitmap;        private set => this.RaiseAndSetIfChanged(ref _bitmap, value);    }    public bool IsCheckedB    {        get => _isCheckedB;        set        {            this.RaiseAndSetIfChanged(ref _isCheckedB, value);            _serializer.BackUp(this);        }    }    public bool IsCheckedG    {        get => _isCheckedG;        set        {            this.RaiseAndSetIfChanged(ref _isCheckedG, value);            _serializer.BackUp(this);        }    }    public bool IsCheckedR    {        get => _isCheckedR;        set        {            this.RaiseAndSetIfChanged(ref _isCheckedR, value);            _serializer.BackUp(this);        }    }    public bool IsCheckedBW    {        get => _isCheckedBW;        set        {            this.RaiseAndSetIfChanged(ref _isCheckedBW, value);            _serializer.BackUp(this);        }    }    public bool BlackAndWhiteFilter    {        get => _blackAndWhiteFilter;        set        {            this.RaiseAndSetIfChanged(ref _blackAndWhiteFilter, value);            _serializer.BackUp(this);        }    }    public bool GreenFilter    {        get => _greenFilter;        set        {            this.RaiseAndSetIfChanged(ref _greenFilter, value);            _serializer.BackUp(this);        }    }    public bool RedFilter    {        get => _redFilter;        set        {            this.RaiseAndSetIfChanged(ref _redFilter, value);            _serializer.BackUp(this);        }    }    public bool BlueFilter    {        get => _blueFilter;        set        {            this.RaiseAndSetIfChanged(ref _blueFilter, value);            _serializer.BackUp(this);        }    }    public bool IsVisibleEffectBtn    {        get => _isVisibleEffectBtn;        set        {            this.RaiseAndSetIfChanged(ref _isVisibleEffectBtn, value);            _serializer.BackUp(this);        }    }    public bool IsVisibleSaveBtn    {        get => _isVisibleSaveBtn;        set        {            this.RaiseAndSetIfChanged(ref _isVisibleSaveBtn, value);            _serializer.BackUp(this);        }    }    public bool IsVisibleRotateBtn    {        get => _isVisibleRotateBtn;        set        {            this.RaiseAndSetIfChanged(ref _isVisibleRotateBtn, value);            _serializer.BackUp(this);        }    }    public bool IsVisibleDrawBtn    {        get => _isVisibleDrawBtn;        set        {            this.RaiseAndSetIfChanged(ref _isVisibleDrawBtn, value);            _serializer.BackUp(this);        }    }    public bool IsVisibleEffectsElements    {        get => _isVisibleEffectsElements;        set        {            this.RaiseAndSetIfChanged(ref _isVisibleEffectsElements, value);            _serializer.BackUp(this);        }    }    public ReactiveCommand<Unit, Unit> OpenEffects { get; }    public ReactiveCommand<Unit, Unit> EnableEffects { get; }    public ReactiveCommand<Unit, Unit> BackFromEffects { get; }    [XmlIgnore] public ReactiveCommand<Unit, Unit> Rotate { get; }    [XmlIgnore] public ReactiveCommand<Unit, Unit> SwipeLeft { get; }    [XmlIgnore] public ReactiveCommand<Unit, Unit> SwipeRight { get; }    [XmlIgnore] public ReactiveCommand<Unit, Unit> Test { get; }    public ReactiveCommand<Unit, Unit> OpenImage { get; }    public ViewModelActivator Activator { get; }    private async Task OnOpenDirectory()    {        try        {            PictureManager.PicturesInFolder = await ShowOpenDirectoryDialog.Handle(Unit.Default);            await _serializer.BackUp(this);        }        catch (Exception)        {            // ImageManager.ResetPictures();        }    }}